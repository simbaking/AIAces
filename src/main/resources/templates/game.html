<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
    <title>Ace's Game</title>
    <link rel="stylesheet" th:href="@{/css/style.css?v=4}" />
</head>

<body>

    <div class="game-container">
        <header>
            <div class="score">
                <h1 style="margin:0; font-size:1.5rem; color:var(--accent);">Ace's</h1>
            </div>
            <div class="message" th:text="${state.gameMessage}">Welcome</div>
            <div class="turn-indicator">
                Turn: <span th:text="${state.currentPlayer.name}"
                    style="color:var(--accent); font-weight:bold;">Player</span>
            </div>

            <!-- Skip Button (Only visible if Human Turn AND Has Drawn) -->
            <!-- Pass/End Turn Button -->
            <form th:action="@{/game/skip}" method="post"
                th:if="${state.currentPlayer.id == human.id and state.hasDrawn}" style="margin-left: 1rem;">
                <input type="hidden" name="playerId" th:value="${human.id}" />

                <!-- If played to stack, show 'Finish Turn' -->
                <button th:if="${state.hasPlayedToStack}" type="submit"
                    style="background:#22c55e; padding: 0.5rem 1rem; border-radius: 8px; border: none; color: white; cursor: pointer; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                    ‚úÖ Finish Turn
                </button>

                <!-- If NOT played to stack (stuck/skip), show 'Skip Turn' -->
                <button th:unless="${state.hasPlayedToStack}" type="submit" style="background:#f59e0b;"
                    class="skip-btn">Skip / Pass</button>
            </form>

            <form id="restartForm" th:action="@{/game/restart}" method="post" style="margin-left:auto;">
                <button type="button" class="danger-btn" onclick="showRestartModal()">Restart</button>
            </form>
        </header>

        <!-- Restart Confirmation Modal -->
        <div id="restartModal" class="modal-overlay" style="display:none;">
            <div class="modal-content">
                <h2 style="margin-top:0; color:#ef4444;">‚ö†Ô∏è Restart Game?</h2>
                <p>This will end the current game and start a new one.</p>
                <div style="display:flex; gap:1rem; justify-content:center; margin-top:1.5rem;">
                    <button onclick="hideRestartModal()" style="background:#6b7280;">Cancel</button>
                    <button onclick="document.getElementById('restartForm').submit();" class="danger-btn">Yes,
                        Restart</button>
                </div>
            </div>
        </div>

        <!-- Tooltip for Brain Nodes -->
        <div id="brainTooltip"
            style="position:fixed; background:rgba(15,23,42,0.95); color:#e2e8f0; padding:12px; border-radius:8px; border:1px solid #3b82f6; font-size:0.85rem; max-width:280px; display:none; pointer-events:none; box-shadow:0 10px 25px rgba(0,0,0,0.5); z-index:9999;">
        </div>

        <!-- CPU Action Banner -->
        <div class="cpu-action-banner" th:if="${state.lastAction != null and !state.lastAction.isEmpty()}"
            th:text="${state.lastAction}"></div>

        <div class="board">
            <div id="poker-table">
                <!-- Center Deck -->
                <div class="center-deck" style="position:relative;">
                    <!-- Bottom Facing Card (Under deck) -->
                    <div th:if="${state.bottomFacingCard != null}" class="bottom-card"
                        title="Bottom Card - Determins 7 Validity"
                        style="position:absolute; top:0px; left:50px; z-index:0; opacity:0.9; transform: rotate(90deg);">
                        <img th:src="${state.bottomFacingCard.imagePath}" class="card-img"
                            style="width:80px; height:112px; border-radius:6px; box-shadow:0 2px 5px rgba(0,0,0,0.3);" />
                    </div>

                    <div id="deckPile"
                        th:class="'card-slot deck deck-3d' + (${state.currentPlayer.id == human.id and !state.hasDrawn} ? '' : ' disabled')"
                        th:onclick="${state.currentPlayer.id == human.id and !state.hasDrawn} ? 'animateDrawCard()' : ''"
                        style="cursor: pointer; z-index:10; position:relative;">
                        <img src="/images/cards/back.png" class="card-img" />
                    </div>
                    <div style="position:absolute; right:-90px; top:50%; transform:translateY(-50%); 
                               color:white; font-weight:bold; text-align:center; z-index:100;
                               background:rgba(0,0,0,0.6); padding:5px 10px; border-radius:8px; pointer-events:none;">
                        <div th:text="${state.drawPile.size()}" style="font-size:1.8rem;">44</div>
                        <div style="font-size:0.8rem; text-transform:uppercase; letter-spacing:1px;">Cards</div>
                    </div>
                    <form id="drawForm" th:action="@{/game/draw}" method="post"
                        th:if="${state.currentPlayer.id == human.id and !state.hasDrawn}">
                        <input type="hidden" name="playerId" th:value="${human.id}" />
                    </form>
                </div>

                <!-- Seats - Dynamically positioned around the table -->
                <!-- Calculate angle for each player: human is at bottom (270deg), others distributed evenly -->
                <div th:each="p, stat : ${state.players}" th:with="humanIdx=${state.players.indexOf(human)}, 
                              total=${state.players.size()},
                              offset=${(stat.index - humanIdx + total) % total},
                              angle=${90 + (offset * 360.0 / total)}"
                    th:class="'seat' + (${p.id == state.currentPlayer.id} ? ' active-turn' : '')"
                    th:style="'--seat-angle: ' + ${angle} + 'deg;'">

                    <!-- Player Info (Name Only) -->
                    <div class="player-info">
                        <span th:text="${p.name}">Player</span>
                        <span th:if="${p.id == state.currentPlayer.id}" style="color:var(--accent);">‚óè</span>
                    </div>

                    <!-- Stack & Discard (On Table) -->
                    <div class="stack-area">
                        <!-- Discard Pile (Droppable) -->
                        <div class="card-slot pile deck-3d" style="transform:scale(0.8);"
                            title="Discard or Drop to Discard" ondragover="allowDrop(event)"
                            ondrop="dropDiscard(event)">
                            <div th:with="top=${p.lastDiscard}" th:remove="tag">
                                <div class="card-container" th:if="${top != null}">
                                    <img th:src="${top.imagePath}" class="card-img" draggable="false" />
                                </div>
                                <div th:if="${top == null}"
                                    style="opacity:0.3; color:white; border:1px dashed #aaa; border-radius:8px;"></div>
                            </div>
                        </div>

                        <!-- Stack (Droppable) - Cascading Display -->
                        <div class="card-slot stack cascading-stack" style="transform:scale(0.8);"
                            title="Stack or Drop to Play" ondragover="allowDrop(event)" ondrop="dropPlay(event)">
                            <!-- Show up to last 5 cards with offset -->
                            <th:block
                                th:with="stackSize=${p.stack.size()}, startIdx=${stackSize > 5 ? stackSize - 5 : 0}">
                                <div th:each="i : ${#numbers.sequence(startIdx, stackSize > 0 ? stackSize - 1 : 0)}"
                                    th:if="${stackSize > 0}" class="card-container stacked-card"
                                    th:style="'--stack-offset:' + ${i - startIdx}">
                                    <img th:src="${p.stack.get(i).imagePath}" class="card-img" draggable="false" />
                                </div>
                            </th:block>
                            <div th:if="${p.stack.isEmpty()}"
                                style="width:100%;height:100%;opacity:0.3; color:white; border:1px dashed #aaa; border-radius:8px;">
                            </div>
                        </div>
                    </div>

                    <!-- CPU Hands (Fanned Visual with Card Backs) -->
                    <th:block th:unless="${p.id == human.id}">
                        <div class="cpu-hand" th:style="'--hand-size:' + ${p.hand.size()}">
                            <!-- Fan the cards with rotation -->
                            <div th:each="i : ${#numbers.sequence(0, p.hand.size() > 0 ? p.hand.size() - 1 : 0)}"
                                th:if="${p.hand.size() > 0}" class="cpu-card-back"
                                th:style="'--fan-i:' + ${i} + '; --fan-total:' + ${p.hand.size()}">
                            </div>
                        </div>
                    </th:block>
                </div>
            </div> <!-- End Table -->

            <!-- HUMAN HAND (Fanned, Foreground, Draggable) -->
            <!-- Give Card Prompt (7) -->
            <div th:if="${state.sevenPassCard and state.currentPlayer.id == human.id}"
                style="position:absolute; bottom:200px; left:50%; transform:translateX(-50%); 
                       background:rgba(0,0,0,0.8); color:#fbbf24; padding:0.5rem 2rem; border-radius:20px; font-weight:bold; box-shadow:0 4px 10px rgba(0,0,0,0.5); z-index:200;">
                ‚ô¶ Select a card to GIVE!
            </div>

            <!-- Human Hand Container -->
            <div class="human-hand-container" id="humanHandContainer">
                <div th:each="card, stat : ${human.hand}" class="card-wrapper"
                    th:style="'--i:' + ${stat.index} + '; --total:' + ${human.hand.size()}">

                    <div class="card-container"
                        th:draggable="${state.currentPlayer.id == human.id and !state.sevenPassCard}"
                        th:data-index="${stat.index}" ondragstart="drag(event)"
                        th:onclick="${state.sevenPassCard} ? 'selectEffect(this.getAttribute(\'data-index\'))' : ''"
                        style="cursor: grab;"
                        th:styleappend="${state.sevenPassCard} ? 'cursor:pointer; border:2px solid #fbbf24;' : ''">
                        <!-- Prevent img from being dragged separately -->
                        <img th:src="${card.imagePath}" class="card-img" draggable="false" />
                    </div>
                </div>
            </div>
        </div>

        <!-- Skip Turn Button (show when it's human's turn and they've drawn) -->
        <div th:if="${state.currentPlayer.id == human.id and state.hasDrawn and !state.modalActive}"
            style="position:fixed; bottom:20px; right:30px; z-index:100;">
            <form th:action="@{/game/skip}" method="post" style="margin:0;">
                <input type="hidden" name="playerId" th:value="${human.id}" />
                <button type="submit"
                    style="padding:0.8rem 1.5rem; font-size:1rem; cursor:pointer; border-radius:8px; background:linear-gradient(135deg, #6b7280, #4b5563); color:white; border:2px solid #9ca3af; box-shadow:0 4px 12px rgba(0,0,0,0.3); transition:all 0.2s ease;"
                    onmouseover="this.style.background='linear-gradient(135deg, #f59e0b, #d97706)'; this.style.transform='scale(1.05)';"
                    onmouseout="this.style.background='linear-gradient(135deg, #6b7280, #4b5563)'; this.style.transform='scale(1)';">
                    ‚è≠Ô∏è Skip Turn
                </button>
            </form>
        </div>

    </div>

    <!-- Effect Modal (only show for human player's turn) -->
    <!-- When sevenPassCard is true, modal should not block the hand -->
    <div class="modal-overlay" th:if="${state.modalActive and state.currentPlayer.pc}"
        th:style="${state.sevenPassCard} ? 'pointer-events:none; bottom:250px; height:auto; top:auto; background:transparent;' : ''">
        <div class="modal-content" th:style="${state.sevenPassCard} ? 'pointer-events:auto;' : ''">
            <!-- Dynamic Header based on Effect -->
            <th:block th:if="${state.selectTarget}">
                <h2 th:if="${state.giveCard}">Give a Card to...</h2>
                <h2 th:if="${state.tradeHands}">Trade Hands with...</h2>
                <h2 th:if="${state.stealCard}">Steal from...</h2>
            </th:block>
            <h2 th:unless="${state.selectTarget}" th:text="${state.gameMessage}">Make a selection</h2>

            <!-- Card Selection (Queen Pick/Order, Joker) -->
            <div class="card-select" th:if="${state.queenPick or state.queenOrder or state.jokerPick}"
                style="display:flex; gap:1rem; justify-content:center;">
                <div th:each="card, stat : ${state.tempBuffer}" class="card-container" th:data-index="${stat.index}"
                    onclick="selectEffect(this.getAttribute('data-index'))"
                    style="cursor:pointer; transform:scale(1.2); width:100px; height:140px;">
                    <img th:src="${card.imagePath}" class="card-img" />
                </div>
            </div>

            <!-- Target Select -->
            <div class="target-select" th:if="${state.selectTarget}"
                style="display:flex; flex-direction:column; gap:1rem;">
                <div th:each="p : ${state.players}" th:unless="${p.id == human.id}">
                    <button th:text="${p.name}" th:data-id="${p.id}"
                        onclick="selectEffect(this.getAttribute('data-id'))"
                        style="padding:1rem 2rem; font-size:1.2rem; cursor:pointer; border-radius:8px; background:#3b82f6; color:white; border:none;"></button>
                </div>
            </div>

            <!-- 8 Card Source Select (3+ players) -->
            <div class="eight-source-select" th:if="${state.eightChooseSource and eightTarget != null}"
                style="display:flex; gap:1rem; justify-content:center; flex-wrap:wrap;">

                <button th:if="${!eightTarget.hand.isEmpty()}" onclick="selectEffect('hand')"
                    style="padding:1rem 2rem; font-size:1.1rem; cursor:pointer; border-radius:8px; background:#22c55e; color:white; border:none;">
                    üé¥ Hand (Pick a card)
                </button>

                <button th:if="${eightTarget.stack.size() > 1}" onclick="selectEffect('stack')"
                    style="padding:1rem 2rem; font-size:1.1rem; cursor:pointer; border-radius:8px; background:#f59e0b; color:white; border:none;">
                    üìö Stack (Top)
                </button>

                <button th:if="${!eightTarget.discardPile.isEmpty()}" onclick="selectEffect('discard')"
                    style="padding:1rem 2rem; font-size:1.1rem; cursor:pointer; border-radius:8px; background:#ef4444; color:white; border:none;">
                    üóëÔ∏è Discard (Top)
                </button>
            </div>

            <!-- 8 Card Face-Down Picking -->
            <div class="eight-pick-cards" th:if="${state.eightPickCard and eightTarget != null}"
                style="display:flex; gap:0.8rem; justify-content:center; flex-wrap:wrap; padding:1rem;">
                <div th:each="i : ${#numbers.sequence(0, eightTarget.hand.size() - 1)}" th:data-index="${i}"
                    onclick="selectEffect(this.getAttribute('data-index'))"
                    style="cursor:pointer; width:80px; height:112px; border-radius:8px; transition:all 0.2s ease; transform-origin:bottom center;"
                    onmouseover="this.style.transform='translateY(-15px) scale(1.15)'; this.style.boxShadow='0 10px 25px rgba(255,215,0,0.4)';"
                    onmouseout="this.style.transform='none'; this.style.boxShadow='none';">
                    <img src="/images/cards/back.png"
                        style="width:100%; height:100%; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.3);" />
                </div>
            </div>


            <!-- Joker Stack Value Selection -->
            <div class="joker-value-select" th:if="${state.jokerStackValue}"
                style="display:flex; gap:0.5rem; justify-content:center; flex-wrap:wrap; padding:1rem;">
                <button onclick="selectEffect('THREE')"
                    style="padding:0.6rem 1rem; font-size:1rem; cursor:pointer; border-radius:6px; background:#8b5cf6; color:white; border:none;">3</button>
                <button onclick="selectEffect('FOUR')"
                    style="padding:0.6rem 1rem; font-size:1rem; cursor:pointer; border-radius:6px; background:#8b5cf6; color:white; border:none;">4</button>
                <button onclick="selectEffect('FIVE')"
                    style="padding:0.6rem 1rem; font-size:1rem; cursor:pointer; border-radius:6px; background:#8b5cf6; color:white; border:none;">5</button>
                <button onclick="selectEffect('SIX')"
                    style="padding:0.6rem 1rem; font-size:1rem; cursor:pointer; border-radius:6px; background:#8b5cf6; color:white; border:none;">6</button>
                <button onclick="selectEffect('SEVEN')"
                    style="padding:0.6rem 1rem; font-size:1rem; cursor:pointer; border-radius:6px; background:#8b5cf6; color:white; border:none;">7</button>
                <button onclick="selectEffect('EIGHT')"
                    style="padding:0.6rem 1rem; font-size:1rem; cursor:pointer; border-radius:6px; background:#8b5cf6; color:white; border:none;">8</button>
                <button onclick="selectEffect('NINE')"
                    style="padding:0.6rem 1rem; font-size:1rem; cursor:pointer; border-radius:6px; background:#8b5cf6; color:white; border:none;">9</button>
                <button onclick="selectEffect('TEN')"
                    style="padding:0.6rem 1rem; font-size:1rem; cursor:pointer; border-radius:6px; background:#8b5cf6; color:white; border:none;">10</button>
                <button onclick="selectEffect('JACK')"
                    style="padding:0.6rem 1rem; font-size:1rem; cursor:pointer; border-radius:6px; background:#8b5cf6; color:white; border:none;">J</button>
                <button onclick="selectEffect('QUEEN')"
                    style="padding:0.6rem 1rem; font-size:1rem; cursor:pointer; border-radius:6px; background:#8b5cf6; color:white; border:none;">Q</button>
            </div>

            <!-- Joker Choice Mode (Stack vs Hand) -->
            <div class="joker-choice-select" th:if="${state.jokerChoiceMode}"
                style="display:flex; gap:1.5rem; justify-content:center; padding:1rem;">
                <button onclick="selectEffect('STACK')"
                    style="padding:1.5rem 2rem; font-size:1.2rem; cursor:pointer; border-radius:12px; background:#f59e0b; color:white; border:none; box-shadow:0 4px 10px rgba(0,0,0,0.3); transition:all 0.2s ease;">
                    üìö Recover 2 to <b>STACK</b>
                    <div style="font-size:0.8rem; opacity:0.8;">Must fit sequence</div>
                </button>
                <button onclick="selectEffect('HAND')"
                    style="padding:1.5rem 2rem; font-size:1.2rem; cursor:pointer; border-radius:12px; background:#3b82f6; color:white; border:none; box-shadow:0 4px 10px rgba(0,0,0,0.3); transition:all 0.2s ease;">
                    ‚úã Recover 1 to <b>HAND</b>
                    <div style="font-size:0.8rem; opacity:0.8;">Any card</div>
                </button>
            </div>

            <div class="cancel-btn" style="margin-top:20px; color:#aaa; font-size:0.8rem;">
                (Action Required)
            </div>
        </div>
    </div>

    <!-- Hidden Actions Forms -->
    <form id="effectForm" th:action="@{/game/effect}" method="post" style="display:none;">
        <input type="hidden" name="playerId" th:value="${human.id}" />
        <input type="hidden" id="effectActionData" name="actionData" />
    </form>

    <form id="playForm" th:action="@{/game/play}" method="post" style="display:none;">
        <input type="hidden" name="playerId" th:value="${human.id}" />
        <input type="hidden" id="playCardIndex" name="cardIndex" />
    </form>

    <form id="discardForm" th:action="@{/game/discard}" method="post" style="display:none;">
        <input type="hidden" name="playerId" th:value="${human.id}" />
        <input type="hidden" id="discardCardIndex" name="cardIndex" />
    </form>
    </div>
    </div>

    <!-- Data for JavaScript -->
    <div id="gameData" th:data-cpu-turn-pending="${state.cpuTurnPending}"
        th:data-is-human-turn="${state.currentPlayer.id == human.id}" th:data-is-game-over="${state.gameOver}"
        th:data-is-modal-active="${state.modalActive}" th:data-last-action="${state.lastAction}"
        th:data-current-player-name="${state.currentPlayer.name}"
        th:data-winner-name="${state.winner != null ? state.winner.name : ''}"
        th:data-winner-ace="${state.winner != null && !state.winner.stack.isEmpty() ? state.winner.stack.get(state.winner.stack.size() - 1).imagePath : ''}"
        style="display:none;"></div>

    <!-- Victory Celebration Overlay -->
    <div id="victoryOverlay" class="victory-overlay" style="display:none;">
        <div id="confettiContainer" class="confetti-container"></div>
        <div class="victory-content">
            <div class="victory-title">üéâ WINNER! üéâ</div>
            <div id="victoryWinnerName" class="victory-winner"></div>
            <img id="victoryAceCard" class="victory-ace" src="" alt="Winning Ace" />
            <div class="victory-buttons">
                <form th:action="@{/game/restart}" method="post" style="margin:0;">
                    <button type="submit" class="victory-btn primary">üîÑ Play Again</button>
                </form>
                <form th:action="@{/game/menu}" method="post" style="margin:0;">
                    <button type="submit" class="victory-btn secondary">üè† Main Menu</button>
                </form>
            </div>
        </div>
    </div>



    <script>
        // Restart Modal Functions
        function showRestartModal() {
            document.getElementById('restartModal').style.display = 'flex';
        }

        function hideRestartModal() {
            document.getElementById('restartModal').style.display = 'none';
        }

        function selectEffect(data) {
            document.getElementById('effectActionData').value = data;
            document.getElementById('effectForm').submit();
        }

        // --- Drag and Drop Logic ---

        function allowDrop(ev) {
            ev.preventDefault(); // Default is to not allow drop
        }

        function drag(ev) {
            // Find the closest card-container in case the image was the target (though img is now draggable=false)
            var target = ev.target.closest('.card-container') || ev.target;
            var index = target.getAttribute("data-index");

            // Put the card index into the data transfer
            ev.dataTransfer.setData("text/plain", index);
            target.style.opacity = '0.5'; // Visual feedback
        }

        function dropPlay(ev) {
            ev.preventDefault();
            var cardIndex = ev.dataTransfer.getData("text/plain");
            // Only submit if valid index (integer string)
            if (cardIndex && !isNaN(cardIndex) && !cardIndex.includes('http')) {
                document.getElementById('playCardIndex').value = cardIndex;
                document.getElementById('playForm').submit();
            } else {
                console.warn("Ignored invalid drop data:", cardIndex);
            }
        }

        function dropDiscard(ev) {
            ev.preventDefault();
            var cardIndex = ev.dataTransfer.getData("text/plain");
            if (cardIndex && !isNaN(cardIndex) && !cardIndex.includes('http')) {
                document.getElementById('discardCardIndex').value = cardIndex;
                document.getElementById('discardForm').submit();
            } else {
                console.warn("Ignored invalid drop data:", cardIndex);
            }
        }

        // Reset opacity if drag ends without drop (HTML5 event)
        document.addEventListener("dragend", function (event) {
            var target = event.target.closest('.card-container') || event.target;
            if (target) target.style.opacity = "1";
        });

        // === DRAW ANIMATION ===
        function animateDrawCard() {
            var deck = document.getElementById('deckPile');
            var drawForm = document.getElementById('drawForm');

            // Get playerId from the hidden form
            var playerIdInput = drawForm ? drawForm.querySelector('input[name="playerId"]') : null;
            var playerId = playerIdInput ? playerIdInput.value : null;

            // Fallback: submit the form directly if we can't animate
            if (!deck || !playerId) {
                if (drawForm) {
                    drawForm.submit();
                } else {
                    location.reload();
                }
                return;
            }

            var deckRect = deck.getBoundingClientRect();

            // Target position: center-bottom of screen where hand would be
            var targetX = window.innerWidth / 2 - 40;
            var targetY = window.innerHeight - 200;

            // AJAX draw to get the card info first
            fetch('/game/draw-ajax', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: 'playerId=' + encodeURIComponent(playerId)
            })
                .then(function (response) { return response.json(); })
                .then(function (data) {
                    if (!data.success) {
                        location.reload();
                        return;
                    }

                    // Create flying card with two sides
                    var flyingCard = document.createElement('div');
                    flyingCard.style.cssText = 'position:fixed; width:80px; height:112px; z-index:9999; pointer-events:none; perspective:1000px;';
                    flyingCard.style.left = deckRect.left + 'px';
                    flyingCard.style.top = deckRect.top + 'px';

                    var inner = document.createElement('div');
                    inner.style.cssText = 'width:100%; height:100%; position:relative; transform-style:preserve-3d; transition:transform 0.6s ease-out;';

                    // Back face
                    var back = document.createElement('img');
                    back.src = '/images/cards/back.png';
                    back.style.cssText = 'position:absolute; width:100%; height:100%; border-radius:6px; box-shadow:0 5px 15px rgba(0,0,0,0.4); backface-visibility:hidden;';

                    // Front face (actual card)
                    var front = document.createElement('img');
                    front.src = data.imagePath;
                    front.style.cssText = 'position:absolute; width:100%; height:100%; border-radius:6px; box-shadow:0 5px 15px rgba(0,0,0,0.4); backface-visibility:hidden; transform:rotateY(180deg);';

                    inner.appendChild(back);
                    inner.appendChild(front);
                    flyingCard.appendChild(inner);
                    document.body.appendChild(flyingCard);

                    // Animate: move and flip
                    setTimeout(function () {
                        flyingCard.style.transition = 'left 0.6s ease-out, top 0.6s ease-out';
                        flyingCard.style.left = targetX + 'px';
                        flyingCard.style.top = targetY + 'px';
                        inner.style.transform = 'rotateY(180deg)';
                    }, 50);

                    // Clean up and reload to show updated state
                    setTimeout(function () {
                        flyingCard.remove();
                        location.reload();
                    }, 700);
                })
                .catch(function (err) {
                    console.error('Draw failed:', err);
                    // Fallback: submit form directly
                    if (drawForm) {
                        drawForm.submit();
                    } else {
                        location.reload();
                    }
                });
        }

        // === CPU AUTO-STEP ===
        (function () {
            var gameData = document.getElementById('gameData');
            if (!gameData) return;

            var cpuTurnPending = gameData.dataset.cpuTurnPending === 'true';
            var isHumanTurn = gameData.dataset.isHumanTurn === 'true';
            var isGameOver = gameData.dataset.isGameOver === 'true';
            var isModalActive = gameData.dataset.isModalActive === 'true';
            var lastAction = gameData.dataset.lastAction || '';
            var cpuName = gameData.dataset.currentPlayerName || '';

            console.log('CPU Step Check:', { cpuTurnPending, isHumanTurn, isGameOver, isModalActive, lastAction });

            // Show animation if there was a CPU action
            if (lastAction && !isHumanTurn && lastAction.includes(cpuName)) {
                animateCpuAction(lastAction);
            }

            if (cpuTurnPending && !isHumanTurn && !isGameOver && !isModalActive) {
                // Auto-submit CPU step after delay (with animation time)
                setTimeout(function () {
                    var form = document.createElement('form');
                    form.method = 'POST';
                    form.action = '/game/cpu-step';
                    document.body.appendChild(form);
                    form.submit();
                }, 6000);
            }
        })();

        function animateCpuAction(action) {
            var deck = document.getElementById('deckPile');
            var discardZone = document.querySelector('.center-discard') || document.querySelector('.discardZone');

            if (!deck) return;

            var deckRect = deck.getBoundingClientRect();

            // Create animated card
            var card = document.createElement('div');
            card.style.cssText = 'position:fixed; width:60px; height:84px; z-index:9999; pointer-events:none; transition:all 0.8s ease-out;';
            card.innerHTML = '<img src="/images/cards/back.png" style="width:100%;height:100%;border-radius:6px;box-shadow:0 8px 20px rgba(0,0,0,0.5);"/>';

            if (action.includes('drew')) {
                // Draw animation: deck -> CPU area (center)
                card.style.left = deckRect.left + 'px';
                card.style.top = deckRect.top + 'px';
                document.body.appendChild(card);

                setTimeout(function () {
                    card.style.left = (window.innerWidth / 2 - 30) + 'px';
                    card.style.top = '150px';
                    card.style.opacity = '0';
                    card.style.transform = 'scale(0.5)';
                }, 50);

                setTimeout(function () { card.remove(); }, 900);
            } else if (action.includes('played') || action.includes('discarded')) {
                // Play/Discard animation: from center down
                card.style.left = (window.innerWidth / 2 - 30) + 'px';
                card.style.top = '100px';
                document.body.appendChild(card);

                setTimeout(function () {
                    card.style.left = (window.innerWidth / 2 - 30) + 'px';
                    card.style.top = '300px';
                    card.style.transform = 'scale(1.2)';
                }, 50);

                setTimeout(function () { card.remove(); }, 900);
            }
        }

        // === VICTORY CELEBRATION ===
        function createConfetti() {
            var container = document.getElementById('confettiContainer');
            if (!container) return;

            var colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dfe6e9', '#fd79a8'];

            for (var i = 0; i < 100; i++) {
                (function (index) {
                    setTimeout(function () {
                        var confetti = document.createElement('div');
                        confetti.className = 'confetti';
                        confetti.style.left = Math.random() * 100 + '%';
                        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                        confetti.style.width = (Math.random() * 10 + 5) + 'px';
                        confetti.style.height = (Math.random() * 15 + 10) + 'px';
                        confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
                        confetti.style.animationDelay = (Math.random() * 0.5) + 's';
                        container.appendChild(confetti);

                        // Remove after animation
                        setTimeout(function () {
                            confetti.remove();
                        }, 4000);
                    }, index * 30);
                })(i);
            }
        }

        function showVictory() {
            var gameData = document.getElementById('gameData');
            if (!gameData) return;

            var winnerName = gameData.dataset.winnerName;
            var winnerAce = gameData.dataset.winnerAce;

            if (!winnerName) return;

            var overlay = document.getElementById('victoryOverlay');
            var nameEl = document.getElementById('victoryWinnerName');
            var aceEl = document.getElementById('victoryAceCard');

            if (overlay && nameEl && aceEl) {
                nameEl.textContent = winnerName + ' placed the Ace!';
                aceEl.src = winnerAce || '/images/cards/ace_spades.png';
                overlay.style.display = 'flex';

                // Start confetti
                createConfetti();

                // More confetti waves
                setTimeout(createConfetti, 1500);
                setTimeout(createConfetti, 3000);
            }
        }

        // Check if game is over and show victory
        (function () {
            var gameData = document.getElementById('gameData');
            if (gameData && gameData.dataset.isGameOver === 'true') {
                // Small delay for dramatic effect
                setTimeout(showVictory, 500);
            }
        })();
    </script>
    </div>

    <!-- AI Brain Visualization Overlay -->
    <div id="aiOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; 
        background:rgba(0,0,0,0.95); z-index:2000; flex-direction:column; align-items:center;">

        <div
            style="width:90%; display:flex; justify-content:space-between; padding:20px; color:white; border-bottom:1px solid #333;">
            <h2>ü§ñ AI Developer Mode <span id="aiName" style="font-size:0.8em; color:#888;">Live Neural
                    Activation</span></h2>

            <!-- Controls -->
            <div style="display:flex; gap:20px; align-items:center;">
                <div style="display:flex; flex-direction:column; color:#94a3b8; font-size:0.75rem;">
                    <span>Weight Focus: <span id="expVal" style="color:#fff; font-weight:bold;">2.0</span></span>
                    <input id="expSlider" type="range" min="0.5" max="10" step="0.1" value="2"
                        style="width:100px; cursor:pointer;" oninput="updateExp(this.value)">
                </div>
                <div style="display:flex; gap:4px; background:#1e293b; padding:4px; border-radius:6px;">
                    <button onclick="setStrat('ALL')" id="btn-ALL" class="strat-btn active-strat">All</button>
                    <button onclick="setStrat(0)" id="btn-0" class="strat-btn"
                        style="border-bottom:2px solid #ef4444;">Aggro</button>
                    <button onclick="setStrat(1)" id="btn-1" class="strat-btn"
                        style="border-bottom:2px solid #3b82f6;">Hoard</button>
                    <button onclick="setStrat(2)" id="btn-2" class="strat-btn"
                        style="border-bottom:2px solid #22c55e;">Plan</button>
                </div>
            </div>

            <button onclick="document.getElementById('aiOverlay').style.display='none'"
                style="padding:8px 16px; background:#ef4444; border:none; cursor:pointer; color:white; border-radius:6px; font-weight:bold;">CLOSE</button>
        </div>

        <style>
            .strat-btn {
                background: transparent;
                border: none;
                color: #64748b;
                padding: 4px 10px;
                cursor: pointer;
                font-weight: bold;
                font-size: 0.8rem;
                border-radius: 4px;
            }

            .strat-btn:hover {
                color: #f1f5f9;
                background: #334155;
            }

            .active-strat {
                background: #475569 !important;
                color: #fff !important;
            }
        </style>

        <div
            style="flex-grow:1; width:100%; position:relative; display:flex; justify-content:center; align-items:center;">
            <canvas id="brainCanvas"
                style="width:95%; height:90%; background:#0f172a; border-radius:12px; box-shadow:0 0 30px #000;"></canvas>

            <!-- Column Labels -->
            <div
                style="position:absolute; bottom:5%; left:5%; color:#94a3b8; font-weight:bold; width:10%; text-align:center;">
                INPUTS</div>
            <div
                style="position:absolute; bottom:5%; left:25%; color:#94a3b8; font-weight:bold; width:10%; text-align:center;">
                PROCESSING</div>
            <div
                style="position:absolute; bottom:5%; left:45%; color:#fbbf24; font-size:1.2em; font-weight:bold; width:10%; text-align:center;">
                STRATEGY</div>
            <div
                style="position:absolute; bottom:5%; right:25%; color:#94a3b8; font-weight:bold; width:10%; text-align:center;">
                TACTICS</div>
            <div
                style="position:absolute; bottom:5%; right:5%; color:#94a3b8; font-weight:bold; width:10%; text-align:center;">
                OUTPUTS</div>
        </div>
    </div>

    <!-- Toggle Button -->
    <button onclick="toggleAiDebug()"
        style="position:fixed; bottom:20px; left:20px; z-index:1000; background:#0f172a; color:#22c55e; border:1px solid #22c55e; padding:8px 15px; font-family:monospace; cursor:pointer; border-radius:4px; font-weight:bold; box-shadow:0 4px 10px rgba(0,0,0,0.5);">
        DEV: BRAIN VIEW üß†
    </button>

    <script th:inline="javascript">
        /*<![CDATA[*/
        var canvas = document.getElementById('brainCanvas');
        var ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        window.addEventListener('resize', resizeCanvas);

        function toggleAiDebug() {
            var overlay = document.getElementById('aiOverlay');
            if (overlay.style.display === 'none') {
                overlay.style.display = 'flex';
                resizeCanvas();
                fetchAiState();
            } else {
                overlay.style.display = 'none';
            }
        }

        function fetchAiState() {
            // IDs are likely "cpu1", "cpu2", etc.
            // Try fetching cpu1 first.
            var targetId = 'cpu1';

            fetch('/ai/state/' + targetId)
                .then(r => r.json())
                .then(data => {
                    // Update Name
                    var nameEl = document.getElementById('aiName');
                    if (nameEl) nameEl.innerText = "Brain: " + targetId.toUpperCase();

                    drawBrain(data);
                    if (document.getElementById('aiOverlay').style.display !== 'none') {
                        setTimeout(fetchAiState, 1000);
                    }
                })
                .catch(e => {
                    console.log("No AI state for " + targetId, e);
                    if (document.getElementById('aiOverlay').style.display !== 'none') {
                        setTimeout(fetchAiState, 2000);
                    }
                });
        }


        var brainNodes = []; // Global storage for node hit testing
        var labelBoxes = []; // Global storage for label hit testing
        var lastAiData = null;
        var weightExponent = 2.0; // Slider value (Default 2)
        var activeStrategy = 'ALL'; // 'ALL', 0, 1, 2

        function updateExp(val) {
            weightExponent = parseFloat(val);
            document.getElementById('expVal').innerText = weightExponent.toFixed(1);
            if (lastAiData) drawBrain(lastAiData);
        }

        function setStrat(s) {
            activeStrategy = s;
            // Update UI
            document.querySelectorAll('.strat-btn').forEach(b => b.classList.remove('active-strat'));
            document.getElementById('btn-' + s).classList.add('active-strat');
            if (lastAiData) drawBrain(lastAiData);
        }

        const NODE_DESCRIPTIONS = [
            "Players: The total number of players in the game.",
            "Pos: My current position in the turn order relative to the dealer.",
            "Stack St: The sum of the value of all cards in every player's stack.",
            "Disc St: The danger level of the discard pile based on recent action cards.",
            "Hand Ct: The total number of cards currently held by all opponents.",
            "# Decks: The number of card decks currently being used.",
            "Pile Sz: The amount of cards remaining in the draw pile.",
            "Bottom: The rank and suit of the bottom card of the deck."
        ];

        // === NEW VISUALIZATION LOGIC ===
        // Color Palette for Inputs
        const INPUT_COLORS = [
            '#9ca3af', // 0: Players (Gray)
            '#facc15', // 1: Pos (Yellow)
            '#3b82f6', // 2: Stack (Blue)
            '#a855f7', // 3: Discard (Purple)
            '#f97316', // 4: Hand (Orange)
            '#06b6d4', // 5: Decks (Cyan)
            '#78350f', // 6: Pile (Brown)
            '#ec4899', // 7: Bottom (Pink)
            '#ef4444', // 8: Aggro Red
            '#b91c1c', // 9: Aggro Dark Red
            '#16a34a', // 10: Hoard Green
            '#8b5cf6', // 11: Plan Purple
        ];

        // Describe Strategy Bottleneck (8-10)
        NODE_DESCRIPTIONS.push("Aggro: Strategy focusing on attacking opponents.");
        NODE_DESCRIPTIONS.push("Hoard: Strategy focusing on building your own hand.");
        NODE_DESCRIPTIONS.push("Plan: Strategy focusing on predicting future states.");
        // Describe Outputs (11-15)
        NODE_DESCRIPTIONS.push("PASS: Do nothing.");
        NODE_DESCRIPTIONS.push("STACK: Play a card to your stack.");
        NODE_DESCRIPTIONS.push("D-SKIP: Discard a Skip Turn card.");
        NODE_DESCRIPTIONS.push("D-ATK: Discard a pure Attack card.");
        NODE_DESCRIPTIONS.push("D-NRM: Discard a normal card.");
        // Describe Aggro-Specific Inputs (16-19)
        NODE_DESCRIPTIONS.push("DistDiff: My distance-to-Ace minus avg opponent distance.");
        NODE_DESCRIPTIONS.push("AvgOppDist: Average opponent distance to Ace.");
        NODE_DESCRIPTIONS.push("MinDist: Smallest distance-to-Ace among all players.");
        NODE_DESCRIPTIONS.push("ClosestPlayer: Which player is closest to winning.");
        // Describe Hoard-Specific Input (20)
        NODE_DESCRIPTIONS.push("HandSize: Number of cards in my hand (Hoard-only input).");

        // Map 38 Inputs to 8 Visual Nodes
        const INPUT_MAPPING = [];
        INPUT_MAPPING[0] = 0; // Players
        INPUT_MAPPING[1] = 1; // Pos
        INPUT_MAPPING[2] = 2; INPUT_MAPPING[3] = 2; INPUT_MAPPING[4] = 3; INPUT_MAPPING[5] = 4; // Self
        for (let i = 0; i < 7; i++) {
            let b = 6 + i * 4;
            INPUT_MAPPING[b] = 2; INPUT_MAPPING[b + 1] = 2; INPUT_MAPPING[b + 2] = 3; INPUT_MAPPING[b + 3] = 4;
        }
        INPUT_MAPPING[34] = 5; // Decks
        INPUT_MAPPING[35] = 6; // Pile
        INPUT_MAPPING[36] = 7; INPUT_MAPPING[37] = 7; // Bottom

        function drawBrain(data) {
            lastAiData = data; // Cache for redraws
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            labelBoxes = []; // Clear label boxes on redraw
            if (!data.inputs || !data.brain) return;

            var brain = data.brain;
            var w = canvas.width;
            var h = canvas.height;
            var pad = 140;

            var stratCount = brain.strategyLayers.length;
            var execCount = brain.executionLayers.length;

            // Stages: Inputs(0) -> Strat(1..N) -> Bot -> Exec(1..M) -> Out
            var totalStages = 1 + stratCount + 1 + execCount + 1;
            var stepX = (w - 2 * pad) / (totalStages - 1);
            var getX = (i) => pad + i * stepX;

            // --- NODES ---
            var stages = [];

            // Stage 0: Aggregated Inputs (8 Nodes)
            var visualInputs = new Array(8).fill(0);
            for (var i = 0; i < INPUT_MAPPING.length; i++) {
                var vIdx = INPUT_MAPPING[i];
                visualInputs[vIdx] += Math.abs(data.inputs[i] || 0);
            }
            var inputNodes = calculateNodes(getX(0), visualInputs, false);
            inputNodes.forEach((n, i) => { n.descIndex = i; n.color = INPUT_COLORS[i]; });
            brainNodes = inputNodes.slice(); // Copy for hit testing
            stages.push(inputNodes);

            // Strategy Layers
            var currentStage = 1;

            brain.strategyLayers.forEach(l => {
                stages.push(calculateNodes(getX(currentStage++), new Array(l.neurons.length).fill(0), false));
            });

            // Bottleneck (3 nodes) - spread out vertically more
            var bnNodes = calculateNodes(getX(currentStage++), data.strategy, true, null, 80);
            bnNodes.forEach((n, i) => { n.descIndex = 8 + i; });
            brainNodes = brainNodes.concat(bnNodes);
            stages.push(bnNodes);

            // Aggro-Specific Input Nodes (4 nodes) - positioned ABOVE everything
            var aggroX = getX(stratCount + 1) - 60; // Near bottleneck
            var aggroInputVals = [
                Math.abs(data.inputs[38] || 0),
                Math.abs(data.inputs[39] || 0),
                Math.abs(data.inputs[40] || 0),
                Math.abs(data.inputs[41] || 0)
            ];
            // Position at top of canvas with horizontal spread
            var aggroNodes = [];
            var aggroTopY = 40; // Near top
            var aggroSpacing = 35;
            for (var ai = 0; ai < 4; ai++) {
                aggroNodes.push({
                    x: aggroX + ai * aggroSpacing,
                    y: aggroTopY,
                    val: aggroInputVals[ai],
                    isKey: false
                });
            }
            aggroNodes[0].descIndex = 16; aggroNodes[0].color = '#ef4444'; // DistDiff
            aggroNodes[1].descIndex = 17; aggroNodes[1].color = '#dc2626'; // AvgOppDist
            aggroNodes[2].descIndex = 18; aggroNodes[2].color = '#b91c1c'; // MinDist
            aggroNodes[3].descIndex = 19; aggroNodes[3].color = '#991b1b'; // ClosestPlayer
            brainNodes = brainNodes.concat(aggroNodes);

            // Hoard-Specific Input Node (1 node) - positioned LEFT of Hoard bottleneck node
            var hoardInputVal = Math.abs(data.inputs[5] || 0); // Self Hand Count (index 5)
            console.log("bnNodes[1] position:", bnNodes[1] ? { x: bnNodes[1].x, y: bnNodes[1].y } : "UNDEFINED");
            var hoardNode = {
                x: bnNodes[1].x - 50, // Left of Hoard node
                y: bnNodes[1].y,      // Same Y as Hoard node
                val: hoardInputVal,
                isKey: false,
                descIndex: 20,
                color: '#16a34a' // Green for Hoard
            };
            console.log("hoardNode created at:", { x: hoardNode.x, y: hoardNode.y });
            brainNodes.push(hoardNode);

            // Exec Layers
            brain.executionLayers.forEach(l => {
                stages.push(calculateNodes(getX(currentStage++), new Array(l.neurons.length).fill(0), false));
            });

            // Output (5 Nodes)
            var outNodes = calculateNodes(getX(currentStage++), data.outputs, true);
            outNodes.forEach((n, i) => { n.descIndex = 11 + i; });
            brainNodes = brainNodes.concat(outNodes);
            stages.push(outNodes);

            // --- CONNECTIONS ---
            // 1. Inputs -> Strat 0
            var s0Filter = activeStrategy !== 'ALL' ? createFilter(brain.strategyLayers[0].neurons.length, activeStrategy) : null;
            drawAggregatedLayerWeights(brain.strategyLayers[0], stages[0], stages[1], s0Filter);

            // 2. Strat -> Strat
            var sIdx = 1;
            for (var i = 1; i < stratCount; i++) {
                var flt = activeStrategy !== 'ALL' ? createFilter(brain.strategyLayers[i].neurons.length, activeStrategy) : null;
                drawLayerWeights(brain.strategyLayers[i], stages[sIdx], stages[sIdx + 1], flt, true);
                sIdx++;
            }

            // 3. Strat -> Bottleneck (first 32 weights)
            var bnLayer = brain.strategyBottleneck;
            if (activeStrategy === 'ALL') {
                drawLayerWeights(bnLayer, stages[sIdx], stages[sIdx + 1], null, true);
            } else {
                drawLayerWeights(bnLayer, stages[sIdx], stages[sIdx + 1], [activeStrategy], true);
            }

            // 3b. Aggro Inputs -> Aggro Bottleneck ONLY
            // Draw connections from 4 Aggro nodes to just the Aggro node (bnNodes[0])
            var aggroWeights = bnLayer.neurons[0].weights.slice(32, 36);
            if (activeStrategy === 'ALL' || activeStrategy === 0) {
                aggroNodes.forEach((an, ai) => {
                    var w = aggroWeights[ai] || 0;
                    drawSingleLine(an, bnNodes[0], w, aggroNodes[ai].color);
                });
            }

            sIdx++;

            // 4. Bottleneck + Inputs -> Exec 0
            var execL0 = brain.executionLayers[0];
            var targetPos = stages[sIdx + 1];
            var bottleneckPos = stages[sIdx];
            var inputsPos = stages[0];

            var bnSourceIndices = (activeStrategy === 'ALL') ? [0, 1, 2] : [activeStrategy];
            drawComplexWeights(execL0, targetPos, [
                { sourceNodes: bottleneckPos, startIndex: 0, count: 3, colors: ['#ef4444', '#3b82f6', '#22c55e'], filterIndices: bnSourceIndices },
                { sourceNodes: inputsPos, startIndex: 3, count: 38, isAggregated: true }
            ]);
            sIdx++;

            // 5. Exec -> Exec
            for (var i = 1; i < execCount; i++) {
                drawLayerWeights(brain.executionLayers[i], stages[sIdx], stages[sIdx + 1]);
                sIdx++;
            }

            // 6. Exec -> Out
            drawLayerWeights(brain.outputLayer, stages[sIdx], outNodes);

            // --- DRAW NODES ---
            stages.forEach((nodes, stgIdx) => {
                nodes.forEach((n, nIdx) => {
                    drawNodeCircle(n, stgIdx, stages.length);
                });
            });
            // Draw Aggro input nodes
            aggroNodes.forEach(n => drawNodeCircle(n, -1, 0));
            // Draw Hoard input node and connection to Hoard bottleneck
            drawNodeCircle(hoardNode, -1, 0);
            if (activeStrategy === 'ALL' || activeStrategy === 1) {
                drawSingleLine(hoardNode, bnNodes[1], 0.5, '#16a34a'); // Visual connection
            }

            function drawNodeCircle(n, stgIdx, maxStg) {
                ctx.beginPath();
                var size = n.isKey ? 8 : (n.descIndex !== undefined ? 5 : 2);
                ctx.arc(n.x, n.y, size, 0, 2 * Math.PI);
                if (n.color) ctx.fillStyle = n.color;
                else if (n.descIndex >= 11 && n.descIndex <= 15) ctx.fillStyle = '#22c55e'; // Output
                else if (n.descIndex >= 8 && n.descIndex <= 10) { // Bottleneck
                    var cols = ['#ef4444', '#3b82f6', '#22c55e'];
                    ctx.fillStyle = cols[n.descIndex - 8];
                } else ctx.fillStyle = '#334155';

                ctx.fill();
                if (n.descIndex !== undefined) {
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                } else {
                    ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 0.5; ctx.stroke();
                }
            }

            // Labels
            var inLabels = ["Plrs", "Pos", "Stk", "Dsc", "Hnd", "Dck", "Pil", "Btm"];
            drawNodeLabels(inputNodes, inLabels, -30, 4, "right");
            ctx.fillStyle = '#fff'; ctx.fillText("Inputs", stages[0][0].x, stages[0][0].y - 30);

            drawNodeLabels(bnNodes, ["Aggro", "Hoard", "Plan"], 0, -25, "center");
            ctx.fillText("Strategy", bnNodes[0].x, bnNodes[0].y - 40);

            var outputLabels = ["PASS", "STACK", "D-SKIP", "D-ATK", "D-NRM"];
            drawNodeLabels(outNodes, outputLabels, 15, 0, "left");
            ctx.fillText("Outputs", outNodes[0].x, outNodes[0].y - 30);

            // Aggro input labels (positioned horizontally at top)
            aggroNodes.forEach((n, i) => {
                var labels = ["Diff", "Opp", "Min", "Who"];
                ctx.fillStyle = n.color;
                ctx.textAlign = "center";
                ctx.fillText(labels[i], n.x, n.y + 20);
            });
            ctx.fillStyle = '#ef4444';
            ctx.textAlign = "center";
            ctx.fillText("Aggro Inputs", aggroNodes[1].x + 15, aggroNodes[0].y - 10);

            // Hoard input label (positioned left of the node)
            ctx.fillStyle = '#16a34a';
            ctx.textAlign = "right";
            ctx.fillText("Hand", hoardNode.x - 10, hoardNode.y + 4);

            // === PLAN PROCESSING NETWORKS ===
            // Draw planPreLayers (left of Plan node) and planPostLayers (right of Plan node)
            if (brain.planPreLayers && brain.planPreLayers.length > 0) {
                var planNode = bnNodes[2]; // Plan is index 2
                var planPreNodes = [];
                var planPostNodes = [];

                // Position: Below Plan node, spread horizontally
                var planNetY = planNode.y + 60; // Below Plan
                var planLayerSpacing = 40; // Horizontal spacing between layers
                var planNodeSpacing = 15; // Vertical spacing between nodes in a layer

                // Pre-network (3 layers, 5 nodes each) - LEFT of Plan
                var preStartX = planNode.x - 80;
                for (var layerIdx = 0; layerIdx < brain.planPreLayers.length; layerIdx++) {
                    var layer = brain.planPreLayers[layerIdx];
                    var layerX = preStartX - (2 - layerIdx) * planLayerSpacing; // Right to left
                    for (var nodeIdx = 0; nodeIdx < layer.neurons.length; nodeIdx++) {
                        var nodeY = planNetY + (nodeIdx - 2) * planNodeSpacing;
                        planPreNodes.push({
                            x: layerX,
                            y: nodeY,
                            layerIdx: layerIdx,
                            nodeIdx: nodeIdx,
                            color: '#a855f7' // Purple for Plan networks
                        });
                    }
                }

                // Post-network (3 layers, 5 nodes each) - RIGHT of Plan
                var postStartX = planNode.x + 80;
                for (var layerIdx = 0; layerIdx < brain.planPostLayers.length; layerIdx++) {
                    var layer = brain.planPostLayers[layerIdx];
                    var layerX = postStartX + layerIdx * planLayerSpacing; // Left to right
                    for (var nodeIdx = 0; nodeIdx < layer.neurons.length; nodeIdx++) {
                        var nodeY = planNetY + (nodeIdx - 2) * planNodeSpacing;
                        planPostNodes.push({
                            x: layerX,
                            y: nodeY,
                            layerIdx: layerIdx,
                            nodeIdx: nodeIdx,
                            color: '#a855f7' // Purple for Plan networks
                        });
                    }
                }

                // Draw connections within pre-network (only if Plan filter active or ALL)
                if (activeStrategy === 'ALL' || activeStrategy === 2) {
                    // Pre layers connections
                    for (var i = 0; i < planPreNodes.length; i++) {
                        var node = planPreNodes[i];
                        if (node.layerIdx > 0) {
                            // Connect to previous layer
                            var prevLayerStart = (node.layerIdx - 1) * 5;
                            for (var j = 0; j < 5; j++) {
                                var prevNode = planPreNodes[prevLayerStart + j];
                                var w = brain.planPreLayers[node.layerIdx].neurons[node.nodeIdx].weights[j] || 0;
                                drawSingleLine(prevNode, node, w, '#a855f7');
                            }
                        }
                    }

                    // Connect last pre layer to Plan node
                    var lastPreLayerStart = 2 * 5; // Layer 2
                    for (var j = 0; j < 5; j++) {
                        var preNode = planPreNodes[lastPreLayerStart + j];
                        drawSingleLine(preNode, planNode, 0.5, '#a855f7');
                    }

                    // Connect Plan node to first post layer
                    for (var j = 0; j < 5; j++) {
                        var postNode = planPostNodes[j]; // First layer
                        drawSingleLine(planNode, postNode, 0.5, '#a855f7');
                    }

                    // Post layers connections
                    for (var i = 0; i < planPostNodes.length; i++) {
                        var node = planPostNodes[i];
                        if (node.layerIdx > 0) {
                            var prevLayerStart = (node.layerIdx - 1) * 5;
                            for (var j = 0; j < 5; j++) {
                                var prevNode = planPostNodes[prevLayerStart + j];
                                var w = brain.planPostLayers[node.layerIdx].neurons[node.nodeIdx].weights[j] || 0;
                                drawSingleLine(prevNode, node, w, '#a855f7');
                            }
                        }
                    }

                    // Connect last post layer to execution (visual only)
                    var lastPostLayerStart = 2 * 5;
                    var execFirstStage = stages[stratCount + 2]; // After bottleneck
                    if (execFirstStage) {
                        for (var j = 0; j < 5; j++) {
                            var postNode = planPostNodes[lastPostLayerStart + j];
                            // Connect to a few exec nodes
                            for (var e = 0; e < Math.min(3, execFirstStage.length); e++) {
                                drawSingleLine(postNode, execFirstStage[e], 0.3, '#a855f7');
                            }
                        }
                    }
                }

                // Draw pre-network nodes
                planPreNodes.forEach(n => {
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, 3, 0, 2 * Math.PI);
                    ctx.fillStyle = n.color;
                    ctx.fill();
                    ctx.strokeStyle = '#1e293b';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                });

                // Draw post-network nodes
                planPostNodes.forEach(n => {
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, 3, 0, 2 * Math.PI);
                    ctx.fillStyle = n.color;
                    ctx.fill();
                    ctx.strokeStyle = '#1e293b';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                });

                // Labels
                ctx.fillStyle = '#a855f7';
                ctx.textAlign = "center";
                ctx.font = 'bold 9px Arial';
                ctx.fillText("Pre", preStartX - planLayerSpacing, planNetY - 30);
                ctx.fillText("Post", postStartX + planLayerSpacing, planNetY - 30);
            }

        }

        function createFilter(count, strategy) {
            var f = [];
            for (var n = 0; n < count; n++) if (n % 3 == strategy) f.push(n);
            return f;
        }

        function calculateNodes(x, values, isKey, startY = null, spacing = null) {
            var nodes = [];
            var count = values.length;
            var canvasH = canvas.height;
            var margin = 60; // Top/bottom margin
            var availableH = canvasH - 2 * margin;

            // Calculate gap: fit all nodes within available height
            var gap = spacing || Math.min(25, availableH / Math.max(count, 1));
            var totalH = count * gap;
            var actualStartY = startY !== null ? startY : margin + (availableH - totalH) / 2 + gap / 2;

            for (var i = 0; i < count; i++) {
                var node = { x: x, y: actualStartY + i * gap, val: values[i], isKey: isKey };
                nodes.push(node);
            }
            return nodes;
        }

        function drawLayerWeights(layer, sourceNodes, targetNodes, targetFilter = null, colorizeSources = false) {
            targetNodes.forEach((tNode, tIdx) => {
                // If filtering targets, skip if not in list
                if (targetFilter && !targetFilter.includes(tIdx)) return;

                var neuron = layer.neurons[tIdx];
                if (!neuron) return;
                neuron.weights.forEach((w, sIdx) => {
                    var sNode = sourceNodes[sIdx];
                    if (sNode) {
                        var color = colorizeSources ? INPUT_COLORS[sIdx % INPUT_COLORS.length] : null;
                        drawSingleLine(sNode, tNode, w, color);
                    }
                });
            });
        }

        function drawAggregatedLayerWeights(layer, sourceNodes, targetNodes, targetFilter = null) {
            targetNodes.forEach((tNode, tIdx) => {
                if (targetFilter && !targetFilter.includes(tIdx)) return;
                var neuron = layer.neurons[tIdx];
                if (!neuron) return;
                // 38 weights -> 8 source nodes
                neuron.weights.forEach((w, wIdx) => {
                    var vIdx = INPUT_MAPPING[wIdx];
                    var sNode = sourceNodes[vIdx];
                    var color = INPUT_COLORS[vIdx];
                    drawSingleLine(sNode, tNode, w, color);
                });
            });
        }

        function drawComplexWeights(layer, targetNodes, segments) {
            targetNodes.forEach((tNode, tIdx) => {
                var neuron = layer.neurons[tIdx];
                if (!neuron) return;

                segments.forEach(seg => {
                    for (var i = 0; i < seg.count; i++) {
                        // Filter logic for SEGMENT (Source Filtering)
                        if (seg.filterIndices && !seg.filterIndices.includes(i)) continue;

                        var wIndex = seg.startIndex + i;
                        if (wIndex >= neuron.weights.length) continue;

                        var w = neuron.weights[wIndex];

                        if (seg.isAggregated) {
                            var vIdx = INPUT_MAPPING[i];
                            var sNode = seg.sourceNodes[vIdx];
                            var color = INPUT_COLORS[vIdx];
                            drawSingleLine(sNode, tNode, w, color);
                        } else {
                            var sNode = seg.sourceNodes[i];
                            var color = seg.colors ? seg.colors[i % seg.colors.length] : null;
                            if (sNode) drawSingleLine(sNode, tNode, w, color);
                        }
                    }
                });
            });
        }

        function drawSingleLine(sNode, tNode, weight, specificColor) {
            var val = Math.abs(weight);
            // Exponential scaling using global weightExponent
            var strength = Math.pow(val, weightExponent);

            // Higher threshold for cleaner visualization - skip weak connections
            if (strength < 0.15) return;

            ctx.beginPath();
            ctx.moveTo(sNode.x, sNode.y);
            ctx.lineTo(tNode.x, tNode.y);

            // Width: 0.1 to 1.0 (Very thin)
            ctx.lineWidth = 0.1 + Math.min(1.0, strength * 1.5);

            if (specificColor) {
                ctx.strokeStyle = specificColor;
                ctx.globalAlpha = Math.min(0.7, strength * 0.6 + 0.1);
            } else {
                ctx.strokeStyle = weight > 0 ? '#60a5fa' : '#f87171';
                ctx.globalAlpha = Math.min(0.5, strength * 0.5);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        function drawNodeLabels(nodes, labels, offsetX, offsetY, align) {
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = align;
            nodes.forEach((n, i) => {
                if (i < labels.length) {
                    var labelText = labels[i];
                    var lx = n.x + offsetX;
                    var ly = n.y + offsetY;
                    var textWidth = ctx.measureText(labelText).width;

                    // Calculate bounding box based on alignment
                    var bx = lx;
                    if (align === 'right') bx = lx - textWidth;
                    else if (align === 'center') bx = lx - textWidth / 2;

                    // Draw button-like background
                    ctx.fillStyle = '#1e293b';
                    ctx.fillRect(bx - 4, ly - 10, textWidth + 8, 14);
                    ctx.strokeStyle = '#475569';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(bx - 4, ly - 10, textWidth + 8, 14);

                    // Draw text
                    ctx.fillStyle = '#e2e8f0';
                    ctx.fillText(labelText, lx, ly);

                    // Store label box for hit testing
                    if (n.descIndex !== undefined) {
                        labelBoxes.push({
                            x: bx - 4, y: ly - 10,
                            w: textWidth + 8, h: 14,
                            descIndex: n.descIndex
                        });
                    }
                }
            });
        }


        // ====== CPU TURN AUTO-TRIGGER ======
        // Check if it's a CPU's turn and automatically process it
        (function () {
            var isHumanTurn = /*[[${state.currentPlayer.pc}]]*/ true;
            var isGameOver = /*[[${state.gameOver}]]*/ false;

            if (!isHumanTurn && !isGameOver) {
                // It's a CPU's turn! Trigger the CPU step after a short delay
                setTimeout(function () {
                    // POST to /game/cpu-step
                    var form = document.createElement('form');
                    form.method = 'POST';
                    form.action = '/game/cpu-step';
                    document.body.appendChild(form);
                    form.submit();
                }, 500); // Small delay for visual feedback
            }
        })();

        canvas.addEventListener('click', function (e) {
            var rect = canvas.getBoundingClientRect();
            var scaleX = canvas.width / rect.width;
            var scaleY = canvas.height / rect.height;
            var mx = (e.clientX - rect.left) * scaleX;
            var my = (e.clientY - rect.top) * scaleY;

            var hit = null;

            // Check label boxes first (text labels as buttons)
            if (typeof labelBoxes !== 'undefined') {
                labelBoxes.forEach(lb => {
                    if (mx >= lb.x && mx <= lb.x + lb.w && my >= lb.y && my <= lb.y + lb.h) {
                        hit = { descIndex: lb.descIndex };
                    }
                });
            }

            // Then check nodes
            if (!hit && typeof brainNodes !== 'undefined') {
                brainNodes.forEach((n) => {
                    var dx = mx - n.x;
                    var dy = my - n.y;
                    if (dx * dx + dy * dy < 150) { // ~12px radius
                        hit = n;
                    }
                });
            }

            var tip = document.getElementById('brainTooltip');
            if (hit && hit.descIndex !== undefined && hit.descIndex < NODE_DESCRIPTIONS.length) {
                var desc = NODE_DESCRIPTIONS[hit.descIndex];
                var parts = desc.split(":");
                tip.innerHTML = "<strong style='color:#60a5fa; display:block; margin-bottom:4px; font-size:1rem;'>" + parts[0] + "</strong>" + parts.slice(1).join(":");
                tip.style.left = (e.clientX + 15) + 'px';
                tip.style.top = (e.clientY + 15) + 'px';
                tip.style.display = 'block';
            } else {
                tip.style.display = 'none';
            }
        });

        /*]]>*/
    </script>
</body>

</html>